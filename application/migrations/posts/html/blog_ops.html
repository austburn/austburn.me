<p>For some time now, I have wanted to apply configuration management to my blog. It's been about a year since I first stood up my blog. I began
with a cloud server, Nginx, and a static HTML page. From there, I graduated to a Python application with Postgres. The next obvious choice
was to shim everything into Docker containers (yes, I was affected by the Great Container Obsession of 2014). During those transitions, I
used scripts and .txt files to make things somewhat repeatable, but they still required my memory and manual intervention - both limited and
error prone.</p>
<p>While the changes I have made have not resulted in any large amounts of downtime, I have had to rush to make hot fixes - frantically debugging, grepping,
and trying to make sense of the situation. Everytime I wanted to add a post or even make a cosmetic change, it was done with perceived caution. What if
my server dies? Will I be able to stand this back up? How much downtime would it cause me? Even though this is a blog that receives a little amount of
traffic, it's <em>my</em> blog - to those on the Interwebs, it serves as a direct representation of myself.</p>
<p>The obvious answer was configuration management. Getting there is another story - that's what I'd like to share here. In this post I'll discuss the
problems I had and how I remedied them. <!-- The main steps to enabling configuration management are (in my opinion): simplify, track, and test. --></p>
<h1>Simplify</h1>
<p>Configuration management is largely about consistency - but we're not there, yet. Before you can leverage configuration management - do you have a
workflow that works?</p>
<p>I didn't.</p>
<p>I had a hundred line text file that contained instructions for how to get my blog running on a cloud server from scratch along with a handful of
scripts that really just helped me run my application, not provision my server. I decline to comment on whether or not that text file was even
useful. (It wasn't).</p>
<p>As a first step, I took a look at what I had and where I wanted to be.</p>
<p>Where I was:</p>
<ul>
    <li>My Docker container was bloated.</li>
    <li>As a result, my dev flow was not extremely useful.</li>
    <li>Had my server died, I'd be at square one.</li>
</ul>
<p>Here is my Docker experience summed up into two memes (I have interchanged which one comes first multiple times:</p>
<div style="text-align:center;">
    <img src="https://bookloversunite.files.wordpress.com/2014/10/do-all-the-things.jpeg" style="width:30%;">
    <img src="http://engineering.viki.com/images/blog/docker_all_the_things.jpg" style="width:30%;">
</div>
<p>As a result, I had 6 Docker images - 5 of which were application based while the latter was my database. The 5 application images consisted of:</p>
<ul>
    <li><strong>base</strong>: install common dependencies (Python, pip, etc.)</li>
    <li>
        <strong>Nginx</strong>
        <ul>
            <li><strong>Dev</strong>: Run on port 80, don't worry about certs, redirects, etc.</li>
            <li><strong>Prod</strong>: Run on port 80/443, worry about certs, redirects, etc.</li>
        </ul>
    </li>
    <li>
        <strong>Application</strong>
        <ul>
            <li><strong>Dev</strong>: Build from dev Nginx image</li>
            <li><strong>Prod</strong>: Build from prod Nginx image</li>
        </ul>
    </li>
</ul>
<p>The problem I had here was: development was slow and not very helpful. I was always indirectly running my Python application via Nginx/uWSGI. If there was
a problem with the application itself, I had to run the application outside the container. Wait... my database is inside a container, too... And I need that
to run my application... Exactly. My dev flow was broken. As a result, I only ever had so much faith in the changes I made. You need a proper development
flow.</p>
<p>This is why I headered this section `Simplify`. The first step to configuration management is really asking: Does this make sense? If someone asks me
how it all works, do I have a straightforward answer?</p>
<p>In my eyes, the source of my problems were largely my Docker images/containers. Ultimately, I decided to yank Nginx out of the container. Can you have Nginx
and your application running inside a container? Of course. I decided to adhere more closely to the
<a href="http://www.catb.org/esr/writings/taoup/html/ch01s06.html">Unix philosophy</a> and have my container do one thing and do it well - my Python
application. This accomplished a few things:</p>
<ul>
    <li>Faster container builds</li>
    <li><code>pdb</code> - <a href="https://docs.python.org/2/library/pdb.html">The Python Debugger</a> which I adore/abuse</li>
    <li>Reduced responsibilities for the container</li>
    <li>Reduced cognitive load</li>
</ul>
<p>At this point, I felt comfortable moving forward. Now, I just need to get Docker, Nginx, and my image to a server.</p>
<h1>Version Control</h1>
<p>Getting started with blogging has been a slowly evolving adventure. Along with work, constantly trying to learn something new, and trying to discover
what I want this blog to become, making updates has ultimately become an infrequent and adaptive process. Each new blog post seems to coincide with spending
time remembering how everything works and how I can make that process better. Fixing things resulted in more time spent understanding. I had no [good]
way of tracking the changes I had made and what problems my new changes might cause.</p>
<p>Version control remedies this problem and provides ways to track and visualize the work you do. Not only does it provide tooling for maintaining, it
provides evidence for any event that occurs. Whether the event is positive or negative - you have a track record to begin to understand the cause.</p>
<p>My biggest barrier to version control was secrets. I had passwords and my SSL certificates/keys hard coded and stored locally. I decided to leverage
<a href="http://docs.ansible.com/ansible/playbooks_vault.html">Ansible Vault</a> to encrypt my sensitive information. Once I had my application cleaned up and
removed all sensitive bits, I was ready to move my source to version control and begin to complete my quest for configuration management.</p>
<h1>Ansible</h1>
<p>asd</p>
