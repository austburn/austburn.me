<p>As of late, I have become increasingly interested in cryptography and network security. Having had a more frontend centric
  set of skills, many of these concerns were outside my scope. As I have worked more with web applications and the backends that
power them, I have become more and more inquisitive about how we make these applications secure for consumers.</p>
<p>Over the past few months I have been dabbling in <a class="content-link" href="https://golang.org/">Go</a>. As a result, I was made aware of the
<a class="content-link" href="http://golang-challenge.com/">Go Challenges</a>. While there are <a class="content-link" href="https://news.ycombinator.com/item?id=9399286">debates</a>
over whether these are meant for beginners trying to grasp the semantics of the language or Go developers competing for prizes, being
introduced to interesting challenges provides direction for development. The inspiration of this post derives from the
<a class="content-link" href="http://golang-challenge.com/go-challenge2/">second Go challenge</a>. Upon a first try, I was unable to complete the challenge in
time, not totally grasping the core concept of the challenge. As a result, I decided to do some research and start from scratch,
building working pieces one at a time. The gist of the challenge was to create a secure server you could connect to and emit
encrypted messages back and forth. This is the basis for the <code>https://</code>, a protocol which layers <code>http://</code> on
top of <a class="content-link" href="http://en.wikipedia.org/wiki/Transport_Layer_Security">TLS/SSL</a>, both of which are cryptographic protocols. The idea
is that you can safely share sensitive information, such as credit card information, over network connections with security
against malicious attackers.</p>
<p>Alright, now that we know <em>what</em> <code>https://</code> is, let's begin to delve a little deeper. We will begin with
some basics for cryptography. The core cryptographic concept that TLS/SSL uses is
<a class="content-link" href="https://developer.mozilla.org/en-US/docs/Introduction_to_Public-Key_Cryptography">public key cryptography</a>. For public
key cryptography, we utilize a pair of keys:</p>
<ul>
<li><strong>Public key</strong> - This is used to encrypt data. We can share this with anyone. You don't have much power being able to
encrypt messages.</li>
<li><strong>Private key</strong> - This is used to decrypt data. DO NOT SHARE! Being able to decrypt
messages that I have encrypted is dangerous.</li>
</ul>
<p>To demonstrate public key cryptograpy, let's look at some code that utilitzes
<a class="content-link" href="https://godoc.org/golang.org/x/crypto/nacl/box"><code>NaCl</code></a>, a popular cryptography toolset ported to Go:</p>
<pre><code class="go">
package main

import(
    "fmt"
    "golang.org/x/crypto/nacl/box"
    "crypto/rand"
)

func main() {
    var firstNonce, secondNonce [24]byte

    // This simply creates a random byte array
    rand.Read(firstNonce[:])
    rand.Read(secondNonce[:])

    myPublicKey, myPrivateKey, _ := box.GenerateKey(rand.Reader)
    yourPublicKey, yourPrivateKey, _ := box.GenerateKey(rand.Reader)

    messageToYou := []byte{'g', 'o', 'l', 'a', 'n', 'g'}

    // Now I will encrypt the messageToYou with your public key
    encryptedForYou := box.Seal(nil, messageToYou, &firstNonce, yourPublicKey, myPrivateKey)

    // You can decrypt this with your private key
    decryptedForYou, _ := box.Open(nil, encryptedForYou, &firstNonce, myPublicKey, yourPrivateKey)
    fmt.Printf("%s\n", decryptedForYou) // prints golang

    // You can read the message I sent you...and send me one back!
    messageToMe := []byte{'i', 's', 'c', 'o', 'o', 'l'}

    // Send me back a message that has been encrypted with my public key
    encryptedForMe := box.Seal(nil, messageToMe, &secondNonce, myPublicKey, yourPrivateKey)

    // I can decrypt and read it with my private key
    decryptedForMe, _ := box.Open(nil, encryptedForMe, &secondNonce, yourPublicKey, myPrivateKey)
    fmt.Printf("%s\n", decryptedForMe) // prints iscool
}
</code></pre>
<p>The only thing in the code example that we haven't really discussed is the idea of a nonce. A <strong>nonce</strong> is a
  <strong>n</strong>umber that is used <strong>o</strong>nce. Get it? Basically, the nonce is a mechanism used to further ensure
  the security of a message. By using a different nonce for each sent message, you further reduce the ability of an attacker
being able to decrypt your communications.</p>
<p>Aside from the nonce, you can see that the core concept shown above is public key cryptography. We each have a public/private keypair.
  I give you my public key, you give me yours. When I send you messages, I encrypt with <em>your</em> public key and you are able to decrypt
  it with your private key. To respond, you encrypt with <em>my</em> public key and I'll decrypt with my private key. Above we
  are performing the same operation twice, but I wanted to demonstrate public key cryptography and the sharing of public keys. This demonstration
will transcend to our final server implementation - think of 'me' and 'you' as the client and the server.</p>
<p>Now we have the basics of public key cryptography hammered out, let's take a look at our server/client:</p>
<pre style="display:inline-block;"><code class="go">
// server.go
package main

import(
    "net"
    "errors"
    "time"
    "fmt"
)

func main() {
    tcpAddr, _ := net.ResolveTCPAddr("tcp", "127.0.0.1:9090")

    // start server
    ln, err := net.ListenTCP("tcp", tcpAddr)
    if err != nil {
        errors.New("Problem setting up server.")
    }

    // continuously accept connections
    for {
        conn, err := ln.AcceptTCP()
        if err != nil {
          errors.New("Error connecting.")
        }
        defer conn.Close()
        go handleConnection(conn)
    }
}

func handleConnection(c *net.TCPConn) {
    const layout = "Jan 2, 2006 at 3:04pm (MST)"
    for {
        msg := make([]byte, 32)
        // read the sent message from the connection
        c.Read(msg)

        // echo it back to the client
        fmt.Fprintf(c, "Echoing back %s at %s", msg,
                    time.Now().Format(layout))
    }
}
</code></pre>
<pre style="display:inline-block;"><code class="go">
// client.go
package main

import(
    "net"
    "errors"
    "fmt"
    "bufio"
    "os"
)

func main() {
    localAddr, _ := net.ResolveTCPAddr("tcp", "127.0.0.1:9090")
    // connect to 127.0.0.1:9090
    conn, err := net.DialTCP("tcp", nil, localAddr)
    if err != nil {
       errors.New("Problem connecting.")
    }
    // read from stdin
    reader := bufio.NewReader(os.Stdin)
    for {
        fmt.Print("> ")
        msg, _ := reader.ReadBytes(0xA)
        // Kill the newline char
        msg = msg[:len(msg) - 1]
        // write to the connection
        _, err := conn.Write(msg)
        response := make([]byte, 1024)
        // read the response
        _, err = conn.Read(response)
        if err != nil {
            fmt.Print("Connection to the server was closed.\n")
            break
        }
        fmt.Printf("%s\n", response)
    }
}
</code></pre>
<p>This is a very simple server and client. The server listens for connections and echos your response back with a timestamp.
  The client starts a connection to the server and displays a prompt to the user. Entering messages sends them to the server
and echos back the server response.</p>
<p>Now we have two separate technologies working as expected. We have the elements of public key cryptography and
a basic client/server. How can we combine these?</p>
<p>Let's discuss the general flow of a secure connection:</p>
<ol>
  <li>Connect to the server.</li>
  <li>Generate a key pair on both the server and the client.</li>
  <li>Swap public keys.</li>
  <li>Begin communication between the client and server.</li>
</ol>
<p>For the most part, the server and the client act the same. The difference being that before we begin our read/write loop on the
server and client, we perform a handshake to swap public keys.</p>
<pre><code class="go">
// server.go
func handleConnection(conn *net.TCPConn) {
    sharedKey := Handshake(conn)
    secureConnection := SecureConnection{conn: conn, sharedKey: sharedKey}
    // Read/write loop
}

// client.go
func (c *Client) Connect() error {
  // Connect to server...
  sharedKey := Handshake(conn)
  secureConnection := SecureConnection{conn: conn, sharedKey: sharedKey}
  // Read/write loop
}

// secure.go
func Handshake(conn *net.TCPConn) *[32] byte {
    var peerKey, sharedKey [32]byte

    publicKey, privateKey, _ := box.GenerateKey(rand.Reader)

    // Deliver the public key
    conn.Write(publicKey[:])

    // Receive the peer key
    peerKeyArray := make([]byte, 32)
    conn.Read(peerKeyArray)

    copy(peerKey[:], peerKeyArray)

    box.Precompute(&sharedKey, &peerKey, privateKey)

    return &sharedKey
}
</code></pre>
<p>As you can see, the way we initiate a connection on the server and client are the same. Our <code>Handshake</code> function generates
  a key pair, writes its public key to the connection and reads the peer's key in from the buffer. <code>box</code> has a convenience
method <code>Precompute</code> which provides a speed optimization for when you will be using the same set of keys as we will.</p>
<p>After we have swapped public keys, we can begin to communicate securely. To avoid cluttering the client and server classes and
  leverage the power of Go, I implemented a <code>SecureConnection</code>. From a high level observation, this <code>SecureConnection</code>
  works like the standard <code>net.Conn</code> interface. Upon closer inspection, the <code>Read</code> and <code>Write</code> methods are using
the <code>NaCl</code> package to encrypt on writes and decrypt on reads:</p>
<pre><code class="go">
// secure.go
func (s *SecureConnection) Write(p []byte) (int, error) {
    var nonce [24]byte

    // Create a new nonce for each message sent
    rand.Read(nonce[:])

    encryptedMessage := box.SealAfterPrecomputation(nil, p, &nonce, s.sharedKey)
    sm := SecureMessage{msg: encryptedMessage, nonce: nonce}

    // Write it to the connection
    return s.conn.Write(sm.toByteArray())
}

func (s *SecureConnection) Read(p []byte) (int, error) {
    message := make([]byte, 2048)

    // Read the message from the buffer
    n, err := s.conn.Read(message)

    // Pulls apart the nonce and message from the byte array we received
    secureMessage := ConstructSecureMessage(message)
    decryptedMessage, ok := box.OpenAfterPrecomputation(nil, secureMessage.msg, &secureMessage.nonce, s.sharedKey)

    if !ok {
        return 0, errors.New("Problem decrypting the message.\n")
    }

    // Actually copy it to the destination byte array
    n = copy(p, decryptedMessage)

    return n, err
}
</code></pre>
<p>On writes, we append the encrypted message to the nonce. What is sent is a random string of bytes. We have to send the nonce
  because the peer needs it to decrypt. When reading, we basically extract the nonce and the message from the sent byte string and use these
  to decrypt the message. While this is a pretty simple application, it buys us secure communication. With the web growing and people
  continuing to trust web applications to hold more and more sensitive data, it is important to know that while communications may not be
private, they are secure against attackers trying to sniff your connection.</p>
<p>With that, we have completed our secure server implementation! For the full code sample, you can check it out
  <a class="content-link" href="https://github.com/austburn/gocrypt">here</a>. If you have any questions, feel
  free to ping me on <a class="content-link" href="https://twitter.com/austburn">Twitter</a>.
</p>
